{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/ICreditOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/// @notice Credit oracle interface: implement your own logic off-chain/on-chain\ninterface ICreditOracle {\n    /// @dev Return whether borrower is allowed, the max amount (in wei),\n    /// APR in basis points (e.g. 1200 = 12% APR), and min duration (seconds).\n    function getTerms(address borrower, uint256 requestedAmount)\n        external\n        view\n        returns (bool allowed, uint256 maxAmount, uint256 aprBps, uint256 minDuration);\n}"
    },
    "contracts/XRPBank.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./ICreditOracle.sol\";\n\n/// @notice Simple bank that accepts XRP and issues uncollateralized loans based on an oracle.\ncontract XRPBank is Ownable, ReentrancyGuard {\n    uint256 private constant YEAR = 365 days;\n\n    struct Loan {\n        uint256 principal;   // wei\n        uint256 aprBps;      // annual percentage rate basis points / cost of the loan\n        uint64  start;       // timestamp\n        uint64  due;         // timestamp\n        bool    active;\n    }\n\n    ICreditOracle public oracle;\n\n    // Depositor bookkeeping (no interest to depositors in this simple demo)\n    mapping(address => uint256) public depositOf;\n    uint256 public totalDeposits;\n\n    // One active loan per borrower\n    mapping(address => Loan) public loanOf;\n    uint256 public totalActivePrincipal;\n\n    event OracleUpdated(address indexed oracle);\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event LoanIssued(address indexed borrower, uint256 amount, uint256 aprBps, uint256 due);\n    event Repaid(address indexed borrower, uint256 principal, uint256 interest, uint256 paid);\n\n    constructor(address oracleAddress) Ownable(msg.sender) {\n        oracle = ICreditOracle(oracleAddress);\n        emit OracleUpdated(oracleAddress);\n    }\n\n    receive() external payable {\n        // Allow plain transfers to count as deposits\n        _deposit(msg.sender, msg.value);\n    }\n\n    function setOracle(ICreditOracle _oracle) external onlyOwner {\n        oracle = _oracle;\n        emit OracleUpdated(address(_oracle));\n    }\n\n    /// @notice Explicit deposit\n    function deposit() external payable nonReentrant {\n        require(msg.value > 0, \"NO_VALUE\");\n        _deposit(msg.sender, msg.value);\n    }\n\n    function _deposit(address user, uint256 amount) internal {\n        depositOf[user] += amount;\n        totalDeposits   += amount;\n        emit Deposited(user, amount);\n    }\n\n    /// @notice Withdraw depositors available funds (limited by contract liquidity)\n    function withdraw(uint256 amount) external nonReentrant {\n        require(amount > 0, \"NO_AMOUNT\");\n        uint256 bal = depositOf[msg.sender];\n        require(bal >= amount, \"INSUFFICIENT_DEPOSIT\");\n        // Liquidity check: only on-chain balance can be withdrawn (loans reduce liquidity)\n        require(address(this).balance >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // Effects\n        depositOf[msg.sender] = bal - amount;\n        totalDeposits        -= amount;\n\n        // Interaction\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"WITHDRAW_FAIL\");\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /// @notice Request a loan; terms come from oracle. One active loan per borrower.\n    /// @param amount Amount of XRP (wei) requested\n    /// @param minDueAt Borrowerâ€™s minimum acceptable due timestamp (protects against unexpectedly short durations)\n    function requestLoan(uint256 amount, uint64 minDueAt) external nonReentrant {\n        require(amount > 0, \"NO_AMOUNT\");\n        Loan storage L = loanOf[msg.sender];\n        require(!L.active, \"LOAN_ACTIVE\");\n\n        (bool allowed, uint256 maxAmount, uint256 aprBps, uint256 minDuration) =\n            oracle.getTerms(msg.sender, amount);\n\n        require(allowed, \"BORROWER_NOT_ALLOWED\");\n        require(amount <= maxAmount, \"ABOVE_MAX\");\n        require(aprBps > 0, \"APR_ZERO\");\n        require(minDuration > 0, \"DUR_ZERO\");\n\n        uint64 start = uint64(block.timestamp);\n        uint64 due   = start + uint64(minDuration);\n        require(due >= minDueAt, \"DUE_TOO_SOON\");\n\n        // Liquidity: bank must have enough native balance to fund loan\n        require(address(this).balance >= amount, \"BANK_ILLQ\");\n\n        // Effects before interaction (plus nonReentrant)\n        L.principal = amount;\n        L.aprBps    = aprBps;\n        L.start     = start;\n        L.due       = due;\n        L.active    = true;\n        totalActivePrincipal += amount;\n\n        // Payout\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"PAYOUT_FAIL\");\n\n        emit LoanIssued(msg.sender, amount, aprBps, due);\n    }\n\n    /// @notice View function to compute current interest & total owed.\n    function quoteOwed(address borrower) public view returns (uint256 principal, uint256 interest, uint256 total) {\n        Loan memory L = loanOf[borrower];\n        if (!L.active) return (0, 0, 0);\n\n        principal = L.principal;\n        uint256 elapsed = block.timestamp > L.start ? (block.timestamp - L.start) : 0;\n\n        // Simple interest = principal * apr * time / (bpsDenom * YEAR)\n        // 1 BPS = 0.01% = 0.0001 = 1/10000\n        // 365 days = time in seconds for a year\n        interest = (principal * L.aprBps * elapsed) / (10000 * YEAR);\n        total = principal + interest;\n    }\n\n    /// @notice Repay the loan in full. Excess is refunded.\n    function repay() external payable nonReentrant {\n        Loan storage L = loanOf[msg.sender];\n        require(L.active, \"NO_LOAN\");\n\n        (uint256 principal, uint256 interest, uint256 total) = quoteOwed(msg.sender);\n        require(msg.value >= total, \"INSUFFICIENT_REPAY\");\n\n        // Effects\n        L.active = false;\n        L.principal = 0;\n        L.aprBps = 0;\n        L.start = 0;\n        L.due = 0;\n        totalActivePrincipal -= principal;\n\n        emit Repaid(msg.sender, principal, interest, msg.value);\n\n        // Refund any overpayment\n        uint256 change = msg.value - total;\n        if (change > 0) {\n            (bool ok, ) = msg.sender.call{value: change}(\"\");\n            require(ok, \"REFUND_FAIL\");\n        }\n    }\n\n    // ----- Admin safety valves (optional) -----\n\n    /// @notice Sweep accidental ERC20s or tokens sent to this contract (not XRP).\n    function rescueERC20(address token, address to, uint256 amount) external onlyOwner {\n        (bool ok, bytes memory data) =\n            token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount));\n        require(ok && (data.length == 0 || abi.decode(data, (bool))), \"ERC20_RESCUE_FAIL\");\n    }\n}\n\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}